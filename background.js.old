// Background script for QBittorrent Remote Connection
console.log("=== BACKGROUND SCRIPT STARTING ===");

// Simple background script without importScripts to avoid loading issues
class QBittorrentBackground {
  constructor() {
    console.log("QBittorrentBackground initializing...");
    this.setupListeners();
    this.setupWebRequestInterceptor();
    this.setupContextMenu();
    console.log("QBittorrentBackground initialization complete");
  }

  setupWebRequestInterceptor() {
    // Handle HTTPS-only mode for local HTTP services
    if (browser.webRequest && browser.webRequest.onBeforeRequest) {
      browser.webRequest.onBeforeRequest.addListener(
        (details) => {
          // Allow HTTP requests to local/private networks
          const url = new URL(details.url);
          if (this.isLocalNetwork(url.hostname)) {
            return { cancel: false };
          }
        },
        {
          urls: ["http://*/*", "https://*/*"],
        },
        ["blocking"]
      );
    }
  }

  isLocalNetwork(hostname) {
    // Check if hostname is a local/private network address
    const localPatterns = [
      /^localhost$/i,
      /^127\./,
      /^192\.168\./,
      /^10\./,
      /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
      /\.local$/i,
    ];

    return localPatterns.some((pattern) => pattern.test(hostname));
  }

  setupListeners() {
    console.log("=== SETTING UP LISTENERS ===");

    // Handle extension installation
    browser.runtime.onInstalled.addListener((details) => {
      console.log("Extension installed/updated:", details);
      if (details.reason === "install") {
        console.log("First install detected");
        this.handleFirstInstall();
      }
    });

    // Handle messages from popup, options, and content scripts
    console.log("Setting up message listener...");
    browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log("Background script received message:", message);
      this.handleMessage(message, sender, sendResponse);
      return true; // Keep message channel open for async response
    });
    console.log("Message listener set up successfully");
    console.log("All listeners set up successfully");
  }

  setupContextMenu() {
    // Create context menu for magnet links
    browser.contextMenus.create({
      id: "addMagnetToQBittorrent",
      title: "Add to QBittorrent",
      contexts: ["link"],
      targetUrlPatterns: ["magnet:*"],
    });

    // Handle context menu clicks
    browser.contextMenus.onClicked.addListener(async (info, tab) => {
      if (info.menuItemId === "addMagnetToQBittorrent" && info.linkUrl) {
        await this.handleAddMagnet(info.linkUrl);
      }
    });
  }

  async handleFirstInstall() {
    // Set default configuration on first install
    await this.setDefaultConfig();

    // Open options page
    browser.tabs.create({
      url: browser.runtime.getURL("options/options.html"),
    });
  }

  async setDefaultConfig() {
    const defaultConfig = {
      serverUrl: "",
      username: "",
      password: "",
      port: "8080",
      useHttps: false,
      autoLogin: false,
    };

    await browser.storage.local.set({ config: defaultConfig });
  }

  async handleMessage(message, sender, sendResponse) {
    console.log("=== BACKGROUND: HANDLING MESSAGE ===");
    console.log("Message object:", message);
    console.log("Message action:", message.action);
    console.log("Message data/settings:", message.data || message.settings);
    console.log("Sender:", sender);

    try {
      switch (message.action) {
        case "getConfig":
          console.log("=== BACKGROUND: GET CONFIG ===");
          const config = await this.getConfig();
          console.log("Retrieved config:", config);
          sendResponse({ success: true, data: config });
          break;

        case "saveConfig":
          console.log("=== BACKGROUND: SAVE CONFIG ===");
          console.log("Config to save:", message.data);
          await this.saveConfig(message.data);
          console.log("Config saved successfully");
          sendResponse({ success: true });
          break;

        case "testConnection":
          console.log("=== BACKGROUND: TEST CONNECTION ===");
          // Handle both old format (message.data) and new format (message.settings)
          const connectionConfig = message.settings || message.data;
          console.log("Connection config received:", {
            ...connectionConfig,
            password: connectionConfig?.password ? "[HIDDEN]" : "",
          });

          const result = await this.testConnection(connectionConfig);
          console.log("Test connection result:", result);
          sendResponse({ success: true, data: result });
          break;

        case "makeRequest":
          // Handle QBittorrent API requests with settings
          const apiResult = await this.makeQBittorrentRequest(
            message.settings,
            message.endpoint,
            message.method,
            message.data
          );
          sendResponse({ success: true, data: apiResult });
          break;

        case "qbittorrentApi":
          const legacyApiResult = await this.makeQBittorrentRequest(
            message.data
          );
          sendResponse({ success: true, data: legacyApiResult });
          break;

        case "addMagnet":
          const magnetResult = await this.handleAddMagnet(
            message.magnetUrl,
            message.options
          );
          sendResponse(magnetResult);
          break;

        case "showMagnetContextMenu":
          // Context menu is already set up, this just acknowledges the request
          sendResponse({ success: true });
          break;

        case "getMagnetSettings":
          const magnetSettings = await this.getMagnetSettings();
          sendResponse({ success: true, data: magnetSettings });
          break;

        case "saveMagnetSettings":
          await this.saveMagnetSettings(message.settings);
          sendResponse({ success: true });
          break;

        default:
          console.log("=== BACKGROUND: UNKNOWN ACTION ===");
          console.log("Unknown action:", message.action);
          sendResponse({ success: false, error: "Unknown action" });
      }
    } catch (error) {
      console.error("=== BACKGROUND SCRIPT ERROR ===");
      console.error("Error object:", error);
      console.error("Error name:", error.name);
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);
      console.error("Original message:", message);
      sendResponse({ success: false, error: error.message });
    }
  }

  async getConfig() {
    const result = await browser.storage.local.get("config");
    return result.config || {};
  }

  async saveConfig(config) {
    await browser.storage.local.set({ config });
  }

  async testConnection(settings) {
    console.log("=== BACKGROUND: TEST CONNECTION METHOD ===");
    try {
      console.log("Input settings:", {
        ...settings,
        password: settings?.password ? "[HIDDEN]" : "",
      });

      // Handle both old format (config) and new format (settings)
      const config = settings.hostname
        ? {
            serverUrl: settings.hostname,
            port: settings.port,
            useHttps: settings.useHttps,
            username: settings.username,
            password: settings.password,
          }
        : settings;

      console.log("Processed config:", {
        ...config,
        password: config?.password ? "[HIDDEN]" : "",
      });

      const protocol = config.useHttps ? "https" : "http";
      const baseUrl = `${protocol}://${config.serverUrl}:${config.port}`;

      console.log("=== TESTING API CONNECTION ===");
      console.log("Protocol:", protocol);
      console.log("Base URL:", baseUrl);

      // Test version endpoint first - simplest API call
      const versionUrl = `${baseUrl}/api/v2/app/version`;
      console.log("Version endpoint URL:", versionUrl);

      console.log("Making fetch request...");
      const versionResponse = await fetch(versionUrl, {
        method: "GET",
        mode: "cors",
        credentials: "omit",
        headers: {
          Accept: "text/plain",
        },
      });

      console.log("=== FETCH RESPONSE RECEIVED ===");
      console.log("Response status:", versionResponse.status);
      console.log("Response status text:", versionResponse.statusText);
      console.log(
        "Response headers:",
        Object.fromEntries(versionResponse.headers.entries())
      );
      console.log("Response ok:", versionResponse.ok);

      if (!versionResponse.ok) {
        const errorMsg = `QBittorrent API returned HTTP ${versionResponse.status}: ${versionResponse.statusText}`;
        console.error("HTTP Error:", errorMsg);
        throw new Error(errorMsg);
      }

      console.log("Reading response text...");
      const version = await versionResponse.text();
      console.log("=== API VERSION RECEIVED ===");
      console.log("QBittorrent API version:", version);

      // Return success with server info
      console.log("=== CONNECTION SUCCESS ===");
      const result = {
        server_version: version,
        api_version: "2.0", // QBittorrent API v2
        connected: true,
      };
      console.log("Returning result:", result);
      return result;
    } catch (error) {
      console.error("=== CONNECTION TEST FAILED ===");
      console.error("Error object:", error);
      console.error("Error name:", error.name);
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);

      // Return error for sendResponse to handle
      throw new Error(error.message);
    }
  }

  // New simplified API request handler
  async makeQBittorrentRequest(
    settings,
    endpoint,
    method = "GET",
    data = null
  ) {
    try {
      const config = settings.hostname
        ? {
            serverUrl: settings.hostname,
            port: settings.port,
            useHttps: settings.useHttps,
            username: settings.username,
            password: settings.password,
          }
        : settings;

      const protocol = config.useHttps ? "https" : "http";
      const baseUrl = `${protocol}://${config.serverUrl}:${config.port}`;
      const url = `${baseUrl}${endpoint}`;

      const requestOptions = {
        method: method,
        mode: "cors",
        credentials: "omit",
        headers: {
          Accept: "application/json",
        },
      };

      // Add data for POST requests
      if (method === "POST" && data) {
        const formData = new FormData();
        Object.keys(data).forEach((key) => {
          formData.append(key, data[key]);
        });
        requestOptions.body = formData;
      }

      const response = await fetch(url, requestOptions);

      if (!response.ok) {
        throw new Error(`API request failed: HTTP ${response.status}`);
      }

      // Handle different response types
      const contentType = response.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        return await response.json();
      } else {
        return await response.text();
      }
    } catch (error) {
      console.error("QBittorrent API request failed:", error);
      throw error;
    }
  }

  async testAuthentication(config, baseUrl) {
    try {
      const loginUrl = `${baseUrl}/api/v2/auth/login`;
      const formData = new FormData();
      formData.append("username", config.username);
      formData.append("password", config.password);

      const response = await fetch(loginUrl, {
        method: "POST",
        mode: "cors",
        credentials: "include",
        body: formData,
      });

      if (response.ok) {
        const result = await response.text();
        if (result === "Ok.") {
          return { success: true };
        } else {
          return { success: false, error: "Invalid username or password" };
        }
      } else {
        return {
          success: false,
          error: `Authentication failed: HTTP ${response.status}`,
        };
      }
    } catch (error) {
      return {
        success: false,
        error: `Authentication error: ${error.message}`,
      };
    }
  }

  async makeQBittorrentRequest(requestData) {
    const config = await this.getConfig();
    const protocol = config.useHttps ? "https" : "http";
    const baseUrl = `${protocol}://${config.serverUrl}:${config.port}`;

    try {
      // Login first if needed and credentials are available
      if (requestData.requiresAuth && config.username && config.password) {
        const authResult = await this.login(config, baseUrl);
        if (!authResult.success) {
          throw new Error(`Authentication failed: ${authResult.error}`);
        }
      }

      const requestHeaders = {
        "User-Agent": "QBittorrent-Remote-Extension/1.0",
        ...requestData.headers,
      };

      const response = await fetch(`${baseUrl}${requestData.endpoint}`, {
        method: requestData.method || "GET",
        mode: "cors",
        credentials: "include",
        headers: requestHeaders,
        body: requestData.body,
      });

      if (response.ok) {
        const contentType = response.headers.get("content-type");
        if (contentType && contentType.includes("application/json")) {
          return await response.json();
        } else {
          const text = await response.text();
          return text.trim();
        }
      } else {
        throw new Error(
          `QBittorrent API error: HTTP ${response.status} - ${response.statusText}`
        );
      }
    } catch (error) {
      console.error("QBittorrent API request failed:", error);
      throw new Error(`API request failed: ${error.message}`);
    }
  }

  async login(config, baseUrl) {
    try {
      const url = `${baseUrl}/api/v2/auth/login`;

      const formData = new FormData();
      formData.append("username", config.username);
      formData.append("password", config.password);

      const response = await fetch(url, {
        method: "POST",
        mode: "cors",
        credentials: "include",
        body: formData,
        headers: {
          "User-Agent": "QBittorrent-Remote-Extension/1.0",
        },
      });

      if (!response.ok) {
        return {
          success: false,
          error: `Login request failed: HTTP ${response.status}`,
        };
      }

      const result = await response.text();
      if (result.trim() === "Ok.") {
        return { success: true };
      } else {
        return { success: false, error: "Invalid credentials" };
      }
    } catch (error) {
      return { success: false, error: `Login error: ${error.message}` };
    }
  }

  /**
   * Handle adding magnet link to QBittorrent
   */
  async handleAddMagnet(magnetUrl, options = {}) {
    try {
      // Load settings and authenticate
      const hasSettings = await this.qbApi.loadSettings();
      if (!hasSettings) {
        return {
          success: false,
          error:
            "QBittorrent not configured. Please set up connection in options.",
        };
      }

      // Test connection first
      const version = await this.qbApi.testConnection();
      if (!version) {
        return {
          success: false,
          error:
            "Cannot connect to QBittorrent. Check your connection settings.",
        };
      }

      // Add the magnet link
      const success = await this.qbApi.addMagnet(magnetUrl, options);

      if (success) {
        // Show success notification
        this.showNotification("Torrent added successfully!", "success");

        // Update icon to show activity (optional)
        this.updateIconForActivity();

        return { success: true, message: "Torrent added successfully" };
      } else {
        return {
          success: false,
          error: "Failed to add torrent to QBittorrent",
        };
      }
    } catch (error) {
      console.error("Error adding magnet:", error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Get magnet handling settings
   */
  async getMagnetSettings() {
    try {
      const result = await browser.storage.local.get("magnet_settings");
      return (
        result.magnet_settings || {
          enableMagnetHandling: true,
          autoAddMagnets: false,
          defaultCategory: "",
          defaultSavePath: "",
          showNotifications: true,
        }
      );
    } catch (error) {
      console.error("Failed to get magnet settings:", error);
      return {};
    }
  }

  /**
   * Save magnet handling settings
   */
  async saveMagnetSettings(settings) {
    try {
      await browser.storage.local.set({ magnet_settings: settings });
    } catch (error) {
      console.error("Failed to save magnet settings:", error);
      throw error;
    }
  }

  /**
   * Show browser notification
   */
  showNotification(message, type = "info") {
    if (browser.notifications) {
      browser.notifications.create({
        type: "basic",
        iconUrl: browser.runtime.getURL("icons/icon-48.png"),
        title: "QBittorrent Remote",
        message: message,
      });
    }
  }

  /**
   * Update extension icon to show activity
   */
  updateIconForActivity() {
    // Set icon to active state
    browser.action.setIcon({
      path: {
        16: "icons/icon-16-active.png",
        32: "icons/icon-32-active.png",
        48: "icons/icon-48-active.png",
      },
    });

    // Reset to normal after 3 seconds
    setTimeout(() => {
      browser.action.setIcon({
        path: {
          16: "icons/icon-16.png",
          32: "icons/icon-32.png",
          48: "icons/icon-48.png",
        },
      });
    }, 3000);
  }
}

// Initialize background script
console.log("=== INITIALIZING BACKGROUND SCRIPT ===");
try {
  const backgroundInstance = new QBittorrentBackground();
  console.log(
    "Background script initialized successfully:",
    !!backgroundInstance
  );
} catch (error) {
  console.error("=== FAILED TO INITIALIZE BACKGROUND SCRIPT ===");
  console.error("Error object:", error);
  console.error("Error name:", error.name);
  console.error("Error message:", error.message);
  console.error("Error stack:", error.stack);
}
